#!/usr/bin/env python
# coding:utf-8

#
# 將聚會手記作後製整理
#
# Author: Chun-Yu Lee (Mat) <matlinuxer2@gmail.com>
# Copyright: Chun-Yu Lee (Mat) <matlinuxer2@gmail.com>
# License: MIT
#

import common
from common import *
from lib.Config import Config
from lib.Wikidot import Wikidot
from lib.Gmail import Gmail
from lib.AuthorData import AuthorData
from lib.GoogleSpreadsheetAPI import Spreadsheet

#
# 程式參數
#
config = Config()
api_user = config['wikidot']['wikidot_api_user']
api_key = config['wikidot']['wikidot_api_key']
site = 'hackingthursday'
root_url = 'http://www.hackingthursday.org'
wikidot = Wikidot()
wikidot.auth(api_user, api_key)
wikidot.set_site(site)
googledoc_user = config['googledoc']['email']
googledoc_pass = config['googledoc']['password']
spreadsheet = config['googledoc']['spreadsheet']
worksheet = config['googledoc']['worksheet']
dryrun = config['googledoc']['dryrun']
dryrun = True

spr = Spreadsheet(googledoc_user, googledoc_pass, spreadsheet)

gmail = Gmail()
gmail.login(googledoc_user, googledoc_pass)

ad_obj = AuthorData()


#
# Main routine below
#

user_mapping_pre = spr.getWorksheetCellArray(worksheet)
ad_obj.user_mapping = convert_spreadsheet_to_userdata(user_mapping_pre)

# 列出要處理的頁面
user_pages = wikidot.list_user_pages()
date_pages = wikidot.list_date_pages()
wikidot.pull_and_cache_pages()  # 下載並更新頁面 cache

date_pages.sort(reverse=True)  # 將最新日期放在最前面
for page in date_pages:
    print("處理頁面: ", page)
    # workaround
    parts = wikidot.partition_page(page)
    ad_obj.parse_data_from_page(page, parts)

#
# 列出每個作者的統計資訊
#
print("==== 列出每個作者的統計資訊 ============================")
authors = ad_obj.list_authors()
for author in authors:
    cnt = 0
    for cc in ad_obj.collection:
        name = cc[0]
        if name == author:
                cnt += 1
    ad_obj.authors_cnt += [(author, cnt)]

ad_obj.authors_cnt.sort(key=lambda x: x[1], reverse=True)

for row in ad_obj.authors_cnt:
    print("%s  %s" % (str(row[1]).rjust(4), row[0]))
exit()
#
# 更新個別作者的頁面
#
print("==== 更新個別作者的頁面 =========================")
authors = ad_obj.list_authors()
for author in authors:
    page_of_author = ad_obj.process_page_per_author(author)
    page = "user:" + author.lower()
    user_head, page_of_author_orig = page_split_by_keyword(wikidot.get_page_content(page), "[[toc]]")
    cnt = ad_obj.get_author_cnt(author.lower())

    if page_of_author == page_of_author_orig or cnt <= 0:
        # 內容沒有變動，或無個人筆記的，跳過不更新
        continue

    # 顯示差異的部分
    out = get_diff_output_between_two_string(page_of_author_orig, page_of_author)
    print("==== %s 新舊差異的部分 ===========" % author)
    print(out)
    print("==================================")

    page_of_author = user_head + page_of_author  # 加上保留的使用者編輯內容

    author_data = ad_obj.find_author_by_name(author)
    name = author_data['rel_name']
    notify = author_data['notify']

    notify_enable = False
    if notify.lower().strip() in ["on", "v", "o", "yes", "y"]:
        notify_enable = True

    title = name + "的聚會手記"

    print("更新個人頁面: %s/%s" % (root_url, page))
    if dryrun is not True:
        if notify_enable is True:
            wikidot.save_page(page, title, page_of_author)
            collect_notify(author)
        else:
            print("Notify 未開通: %s => %s/%s" % (author, root_url, page))
            collect_unnotify(author)


#
# Calucate user statics
#
ary_local = ad_obj.list_authors()
ary_remote = []
for user_page in user_pages:
        user = user_page[5:]
        ary_remote += [user]

ary_all = set(ary_local + ary_remote)

ary_local_gt_remote = []
ary_local_eq_remote = []
ary_local_lt_remote = []

for item in ary_all:
        if item in ary_local and item in ary_remote:
                ary_local_eq_remote += [item]
        elif item in ary_local and not item in ary_remote:
                ary_local_gt_remote += [item]
        elif not item in ary_local and item in ary_remote:
                ary_local_lt_remote += [item]
        else:
                print("例外: %s" % item)

print("== 本地有，遠端有 ======================")
for x in ary_local_eq_remote:
        print("%s/user:%s" % (root_url, x))
print("== 本地有，遠端沒有 ====================")
for x in ary_local_gt_remote:
        print("%s/user:%s" % (root_url, x))
print("== 本地沒有，遠端有 ====================")
for x in ary_local_lt_remote:
        print("%s/user:%s" % (root_url, x))
print("========================================")


# 展開作者列表
page_of_index = ad_obj.make_index_of_authors()
print(page_of_index)

# 將作者列表塞到主選單中
nav_page = "nav:top"
keyword_beg = "\n* [# H4ckers]\n"
keyword_end = "\n  * [[[user:non-en]]]\n"

nav_top_page = wikidot.get_page(nav_page)
nav_top_content = nav_top_page["content"].encode('utf8')

new_nav_top_content = find_keyword_and_insert_content(nav_top_content, keyword_beg, keyword_end, page_of_index)
if dryrun is not True:
    wikidot.save_page(nav_page, content=new_nav_top_content)

#
# 通知作者有頁面更新
#
print("==== 通知作者有頁面更新 ==================================")
for author in ad_obj.collection3:
    author_data = ad_obj.find_author_by_name(author)
    rel_name = author_data['rel_name']
    url_name = author_data['url_name']
    email = author_data['email']
    notify = author_data['notify']
    notify_enable = False

    if notify.lower().strip() in ["on", "v", "o", "yes", "y"]:
        notify_enable = True

    if notify_enable:
            print('To nofity: "%s" <%s> , %s/user:%s ' % (rel_name, email, root_url, url_name))
            if dryrun is not True:
                send_notify_mail(author, ad_obj, googledoc_user, root_url)
    else:
            print('  skiping: "%s" <%s> , %s/user:%s ' % (rel_name, email, root_url, url_name))

print("==== 未對應之作者 ==================================")
for item in ad_obj.collection2:
        print("%s/%s '%s' " % (root_url, item[0], item[1]))

print("==== 未開通之作者 ==================================")
for item in ad_obj.collection4:
        print(item)
